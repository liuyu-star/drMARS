library(MASS)
library(plot3D)
library(latex2exp)
source('gKDR/gKDR.R')
#source('drMARS/drMARS.R')
#source('drMARS/drMARS.CV.R')
source('drMARS/drMARS.fit.R')
source('drMARS/MARS.component.R')

# The training set (x, y) and the test set (xnew, ynew) are generated by model 6 in the paper.
set.seed(2305)
p=100
n=500
N=10*n
S=0.6^abs(outer(seq(p),seq(p),"-")) 
mu=rep(0,p)
X=mvrnorm(n+N,mu,S)

# model 6 (M6)
fx = X[,1]*(X[,1]+X[,2]+1)
B0=matrix(0,nrow = p,ncol = 2)
# the true SDR space.
B0[1,1]=c(1)
B0[1:2,2]=c(1,1)/sqrt(2)

x=X[seq(n),]
xnew=X[-seq(n),]
snr=2
y = fx[seq(n)] + rnorm(n)/snr
ynew=fx[-seq(n)]

# the true dimensions of the SDR space.
d=ncol(B0)



#############################Estimate SDR space#################################
#The estimation accuracy of the SDR space is evaluated with the true dimensions of the SDR space.
# Using gKDR
B=as.matrix(gKDR(x, y, K=d, Method="gKDR-v")) 
print(head(B))

# Estimation error
BB0=B0%*%solve(t(B0)%*%B0)%*%t(B0)
#B = B/matrix(sqrt(colSums(B^2)), p, d, byrow=TRUE)
err=sqrt(sum(diag(t(B)%*%(diag(p)-BB0)%*%B))/d)
print(err)


# Using drMARS
B = drMARS(x,y,degree = NULL,Xscale=F,plus=F)$B[,seq(d),drop=F]
print(head(B))

# Estimation error
BB0=B0%*%solve(t(B0)%*%B0)%*%t(B0)
#B = B/matrix(sqrt(colSums(B^2)), p, d, byrow=TRUE)
err=sqrt(sum(diag(t(B)%*%(diag(p)-BB0)%*%B))/d)
print(err)



#############################Estimation the dimension of the SDR space (d)#################################
#we select the dimension of the SDR space (d) by 10-fold cross-validation.
# Using gKDR
cv=-Inf
max.dim=5
for (d in seq(max.dim)) {
  B0=gKDR(x, y, K=d, Method="gKDR-v")
  gcvs=sapply(seq(min(3,ncol(B0))),function(df)earth(x%*%B0, y, degree=df)$gcv)
  df=which.min(gcvs)
  
  set.seed(230516)
  cvi=earth(x%*%B0, y, degree=1,nfold=10)$cv.rsq.tab[11,2]
  if(cvi>cv){
    cv=cvi
    B=B0
    ndir=d
  }
}

print(ndir)


# Using drMARS
B = drMARS(x,y,degree = NULL,Xscale=F,plus=F)$B
d=drMARS.CV(B, max.dim=5, nfold=10)$ndir
print(d)



#############################Performance of prediction#################################
# Using MARS
smp=seq(min(p,4))
gcv.mars=Inf
for (df in smp) {
  #set.seed(230516)
  fiti=earth(x, y, degree=df)#,  nfold=10)
  if(fiti$gcv<gcv.mars){
    fit.mars=fiti
    gcv.mars=fiti$gcv
    df.mars=df
  }
}
gcv.mars=log(fit.mars$gcv) + log(n)*(0+nrow(fit.mars$coefficients))/n
pred = predict(fit.mars, xnew)
pred[which(pred<min(fit.mars$fitted))]=min(fit.mars$fitted)
pred[which(pred>max(fit.mars$fitted))]=max(fit.mars$fitted)

# Prediction error
e.MARS = mean(abs(pred-ynew)^2)
print(e.MARS)


# Using drMARS

# We provide a number of arguments to make predictions using drMARS, 
# and users need to adjust the arguments to improve the prediction accuracy of drMARS based on the data.
# The usage of the parameters is described in the file "drMARS.R".

A = drMARS.fit(x,y,xnew,degree = NULL,Xadd=T,Xnorm=F,Xscale=F,plus=F,iter=F,ndir="NoPreSel",max.dim = 5,max.iter=50)
pred=A$predicted

# Prediction error
e.drMARS = mean(abs(pred-ynew)^2)
print(e.drMARS)



#############################Plotting three-dimensional graphs#################################
d=2
BB = drMARS(x,y,degree = NULL,Xscale=F,plus=F)$B
B=BB[,seq(d),drop=F]
xB=x%*%B
colnames(xB)=paste0("x",seq(ncol(xB)))
fit.drmars = earth(xB, y, degree=2)

# The regression model estimated by drMARS.
Coef=fit.drmars$coefficients
print(Coef)


# Plotting three-dimensional graphs.
#B0=B
#B=(abs(B0)>0.01)*B0
xb = x%*%B
#fv=fit.drmars$fitted.values
#v1=xb[,1]
#v2=xb[,2]
#v3=xb[,3]


nv=30
xB1=seq(min(xb[,1]),max(xb[,1]),length.out=nv)
xB2=seq(min(xb[,2]),max(xb[,2]),length.out=nv)
xB12 <- mesh(xB1,xB2)

xB=cbind(c(xB12$x),c(xB12$y))
fx=MARS.component(Coef, x=as.matrix(xB))
fxB12=matrix(rowSums(fx$fxValue)+Coef[1],ncol = nv)
#fv12=matrix(predict(fit.drmars,xB),ncol = nv)

win.graph()
par(mfrow=c(1,2))

persp(xB1, xB2, fxB12, xlab= "xB1",ylab="xB2",zlab="fitted function g1(.)+g2(.)+g12(.,.)",
      phi = 0, theta = 40,ticktype = "detailed", col = "lightblue",cex.axis=2,cex.lab=2.5)
#zlab="fitted values E(Y|X)"
#zlab="fitted function g1(.)+g2(.)+g12(.,.)"

x12=xB%*%solve(B[seq(2),seq(2)])
x1=x12[,1]
x2=x12[,2]
fx12=matrix(x1*(x1+x2+1),ncol = nv)

#x1=seq(min(x[,1]),max(x[,1]),length.out=nv)
#x2=seq(min(x[,2]),max(x[,2]),length.out=nv)
#x12 <- mesh(x1,x2)
#x12=cbind(c(x12$x),c(x12$y))
#fx12=matrix(x12[,1]*(x12[,1]+x12[,2]+1),ncol = nv)

persp(xB1, xB2, fx12, xlab= "xB1",ylab="xB2",zlab="real function x1(x1+x2+1)",
      phi = 0, theta = 40,ticktype = "detailed", col = "lightblue",cex.axis=2,cex.lab=2.5)

  